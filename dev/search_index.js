var documenterSearchIndex = {"docs":
[{"location":"dialogs/#Dialogs","page":"Dialogs","title":"Dialogs","text":"The TclTk package exports a number of dialog widgets provided by Tk. Dialog options are specified as key => val pairs where key is the option name (a string, a symbol, or a Tcl object) without its leading hyphen and val is the option value. The value returned returned when the dialog is closed depend on the type of dialog, it is usually a string but it may also be a vector of strings (for instance, if multiple selection is allowed in the tk_getOpenFile dialog).\n\nFor example:\n\nanswer = tk_messageBox(:message => \"Really quit?\", :icon => :question, :type => :yesno,\n                       :detail => \"Select \\\"Yes\\\" to make the application exit\")\nif answer == \"yes\"\n    quit()\nelseif answer == \"no\"\n    tk_messageBox(:message => \"I know you like this application!\", :type => :ok)\nend\n\ntk_start is automatically called by the dialog widgets.","category":"section"},{"location":"dialogs/#Choosing-a-color","page":"Dialogs","title":"Choosing a color","text":"Interactively choosing a color can be done by (using ColorTypes is to import RGB among others):\n\nusing ColorTypes\ncolor = tk_chooseColor(:title => \"Choose a nice color\", :initialcolor => RGB(1.0, 0.867, 0.267))\n\nWhich gives:\n\n(Image: `Tk_chooseColor` dialog)\n\nIf the user cancel the operation of close the dialog window, nothing is returned; otherwise, the returned color can be used to configure a Tk widget. For example:\n\ntop = TkToplevel(interp, :background => color)","category":"section"},{"location":"dialogs/#Language-for-messages","page":"Dialogs","title":"Language for messages","text":"The text of standard labels is automatically chosen ny Tk according to locale settings. You may want to set one of the environment variables LC_ALL, LC_MESSAGES, or LANG to set the language for dialog widgets before starting TclTk. For example:\n\nENV[\"LC_ALL\"] = \"en_US\"\nusing TclTk","category":"section"},{"location":"dialogs/#Standard-dialogs","page":"Dialogs","title":"Standard dialogs","text":"The following Tk dialog widgets are available:","category":"section"},{"location":"dialogs/#TclTk.Impl.tk_chooseColor","page":"Dialogs","title":"TclTk.Impl.tk_chooseColor","text":"tk_chooseColor(interp=TclInterp(), option => value, ...)\n\nPop up a Tk dialog box for the user to select a color and return the chosen color as an instance of TkRGB{UInt8} or nothing if the user cancels the dialog. Tcl interpreter interp is used to run the dialog.\n\nOptions\n\nSymbols and strings are equivalent for specifying the option names and their values. Available options are:\n\nOption :parent specifies the logical parent of the message box. The color dialog box is displayed on top of its parent window.\nOption :title specifies the title of the message box.\nOption :initialcolor specifies the color to display in the color dialog when it pops up. The value of this option can be a string like \"orange\" or \"#ff03ae\" or an instance of a sub-type of TkColor.\n\nSee also\n\ntk_chooseDirectory, tk_getOpenFile, tk_getSaveFile, and tk_messageBox.\n\n\n\n\n\n","category":"function"},{"location":"dialogs/#TclTk.Impl.tk_chooseDirectory","page":"Dialogs","title":"TclTk.Impl.tk_chooseDirectory","text":"tk_chooseDirectory(interp=TclInterp(), option => value, ...) -> dir::String\n\nPop up a Tk dialog box for the user to select a directory and return the chosen directory name (an empty string if none). Tcl interpreter interp is used to run the dialog. Available keywords are:\n\nOptions\n\nSymbols and strings are equivalent for specifying the option names and their values. Available options are:\n\nOption :parent specifies the window of the logical parent of the message box. The message box is displayed on top of its parent window.\nOption :title specifies the title of the message box. This option is ignored on Mac OS X, where platform guidelines forbid the use of a title on this kind of dialog.\nOption :message specifies the message to display in this message box. The default value is an empty string. This is only available on Mac OS X.\nOption :initialdir specifies that the directories in directory should be displayed when the dialog pops up. If this parameter is not specified, the initial directory defaults to the current working directory on non-Windows systems and on Windows systems prior to Vista. On Vista and later systems, the initial directory defaults to the last user-selected directory for the application. If the parameter specifies a relative path, the return value will convert the relative path to an absolute path.\nOption :mustexist specifies whether the user may specify non-existent directories. If this parameter is true, then the user may only select directories that already exist.\nOption :command specifies the prefix of a Tcl command to invoke when the user closes the dialog. The actual command consists of string followed by a space and the name of the button clicked by the user to close the dialog. This is only available on Mac OS X.\n\nSee also\n\ntk_chooseColor, tk_getOpenFile, tk_getSaveFile, and tk_messageBox.\n\n\n\n\n\n","category":"function"},{"location":"dialogs/#TclTk.Impl.tk_getOpenFile","page":"Dialogs","title":"TclTk.Impl.tk_getOpenFile","text":"tk_getOpenFile(interp=TclInterp(), option => value, ...)\n\nPop up a Tk dialog box for the user to select a file to open and return the name of the chosen file (an empty string if none). Tcl interpreter interp is used to run the dialog.\n\nOptions\n\nSymbols and strings are equivalent for specifying the option names and their values. Available options are:\n\nOption :parent specifies the path of the logical parent of the file dialog. The file dialog is displayed on top of its parent window. On Mac OS X, this turns the file dialog into a sheet attached to the parent window.\nOption :title specifies a string to display as the title of the dialog box. If this option is not specified, then a default title is displayed.\nOption :message Specifies a message to include in the client area of the dialog. This is only available on Mac OS X.\nOption :initialdir specifies the directory in which the files should be displayed when the dialog pops up. If this parameter is not specified, the initial directory defaults to the current working directory on non-Windows systems and on Windows systems prior to Vista. On Vista and later systems, the initial directory defaults to the last user-selected directory for the application. If the parameter specifies a relative path, the return value will convert the relative path to an absolute path.\nOption :initialfile specifies a filename to be displayed in the dialog when it pops up.\nOption :multiple specifies whether the user can choose multiple files from the Open dialog. If multiple files are chosen, a vector of strings is returned.\nOption :defaultextension specifies a string that will be appended to the filename if the user enters a filename without an extension. The default value is the empty string, which means no extension will be appended to the filename in any case. This option is ignored on Mac OS X, which does not require extensions to filenames, and the UNIX implementation guesses reasonable values for this from the filetypes option when this is not supplied.\nIf a file types listbox exists in the file dialog on the particular platform, option :filetypes gives the filetypes in this listbox. When the user choose a filetype in the listbox, only the files of that type are listed. If this option is unspecified, or if it is set to the empty list, or if the File types listbox is not supported by the particular platform then all files are listed regardless of their types. See Tk manual for more details.\nOption :typevariable specifies the name of a global Tcl variable used to preselect which filter is used from filterList when the dialog box is opened and is updated when the dialog box is closed, to the last selected filter. The variable is read once at the beginning to select the appropriate filter. If the variable does not exist, or its value does not match any filter typename, or is empty ({}), the dialog box will revert to the default behavior of selecting the first filter in the list. If the dialog is canceled, the variable is not modified.\nOption :command specifies the prefix of a Tcl command to invoke when the user closes the dialog after having selected an item. This callback is not called if the user cancelled the dialog. The actual command consists of the command string followed by a space and the value selected by the user in the dialog. This is only available on Mac OS X.\n\nSee also\n\ntk_getOpenFile, tk_chooseColor, tk_chooseDirectory, and tk_messageBox.\n\n\n\n\n\n","category":"function"},{"location":"dialogs/#TclTk.Impl.tk_getSaveFile","page":"Dialogs","title":"TclTk.Impl.tk_getSaveFile","text":"tk_getSaveFile(interp=TclInterp(), option => value, ...)\n\nPop up a Tk dialog box for the user to select a file to save and return the name of the chosen file (an empty string if none). Tcl interpreter interp is used to run the dialog.\n\nOptions\n\nSymbols and strings are equivalent for specifying the option names and their values. Available options are:\n\nFor options :parent, :title, :message, :initialdir, :initialfile, :defaultextension, :filetypes, :typevariable, and :command, see tk_getSaveFile.\nOption :confirmoverwrite configures how the Save dialog reacts when the selected file already exists, and saving would overwrite it. A true value requests a confirmation dialog be presented to the user. A false value requests that the overwrite take place without confirmation.\n\nSee also\n\ntk_getSaveFile, tk_chooseColor, tk_chooseDirectory, and tk_messageBox.\n\n\n\n\n\n","category":"function"},{"location":"dialogs/#TclTk.Impl.tk_messageBox","page":"Dialogs","title":"TclTk.Impl.tk_messageBox","text":"tk_messageBox(interp=TclInterp(), option => value, ...) -> answer::String\n\nPop up a Tk message box dialog and return the name of the selected button. Tcl interpreter interp is used to run the dialog.\n\nOptions\n\nSymbols and strings are equivalent for specifying the option names and their values. Available options are:\n\nOption :parent specifies the window of the logical parent of the message box. The message box is displayed on top of its parent window.\nOption :title specifies the title of the message box. This option is ignored on Mac OS X, where platform guidelines forbid the use of a title on this kind of dialog.\nOption :message specifies the message to display in this message box. The default value is an empty string.\nOption :detail specifies an auxiliary message to the main message. The message detail will be presented beneath the main message and, where supported by the OS, in a less emphasized font than the main message.\nOption :icon specifies an icon to display: :error, :info, :question or :warning. By default, the :info icon is displayed.\nOption :type specifies which predefined set of buttons is displayed. The following values are possible:\n:abortretryignore to display three buttons whose symbolic names are :abort, :retry and :ignore.\n:ok to display one button whose symbolic name is :ok.\n:okcancel to display two buttons whose symbolic names are :ok and :cancel.\n:retrycancel to display two buttons whose symbolic names are :retry and :cancel.\n:yesno to display two buttons whose symbolic names are :yes and :no.\n:yesnocancel to display three buttons whose symbolic names are :yes, :no and :cancel.\nOption :default gives the name of the default button for this message window (:ok, :cancel, and so on). See keyword type for a list of the button names. If this option is not specified, the first button in the dialog will be made the default.\nOption :command specifies the prefix of a Tcl command to invoke when the user closes the dialog. The actual command consists of string followed by a space and the name of the button clicked by the user to close the dialog. This is only available on Mac OS X.\n\nExamples\n\nanswer = tk_messageBox(:message => \"Really quit?\", :icon => :question, :type => :yesno,\n                       :detail => \"Select \"Yes\" to make the application exit\")\nif answer == \"yes\"\n    quit()\nelseif answer == \"no\"\n    tk_messageBox(:message => \"I know you like this application!\", :type => :ok)\nend\n\nSee also\n\ntk_chooseColor, tk_chooseDirectory, tk_getOpenFile, and and tk_getSaveFile.\n\n\n\n\n\n","category":"function"},{"location":"develop/#Internal-API-for-developers","page":"Internal API for developers","title":"Internal API for developers","text":"","category":"section"},{"location":"develop/#TclTk.Impl.WrappedObject","page":"Internal API for developers","title":"TclTk.Impl.WrappedObject","text":"WrappedObject\n\nAbstract super-type of Julia objects that reflect or wrap a Tcl object.\n\nSuch objects implement TclTk.Impl.unsafe_objptr to yield a checked pointer to their associated Tcl object.\n\n\n\n\n\n","category":"type"},{"location":"develop/#TclTk.Impl.Tcl_DecrRefCount","page":"Internal API for developers","title":"TclTk.Impl.Tcl_DecrRefCount","text":"TclTk.Impl.Tcl_DecrRefCount(objptr) -> refcnt\n\nDecrement the reference count of the Tcl object given its pointer and return its new reference count. If refcnt < 1 holds, the Tcl object has been released and objptr shall no longer be used.\n\nThis method emulates the Tcl_DecrRefCount macro defined in <tcl.h>.\n\nwarning: Warning\nUnsafe function: object pointer must not be null and must remain valid during the call to this function.\n\nSee also\n\nTclTk.Impl.Tcl_IncrRefCount and TclTk.Impl.Tcl_GetRefCount.\n\n\n\n\n\n","category":"function"},{"location":"develop/#TclTk.Impl.Tcl_GetRefCount","page":"Internal API for developers","title":"TclTk.Impl.Tcl_GetRefCount","text":"TclTk.Impl.Tcl_GetRefCount(objptr) -> refcnt\n\nReturn the current reference count of the Tcl object at address objptr.\n\nThis is not provided in <tcl.h> but is useful.\n\nwarning: Warning\nUnsafe function: object pointer must not be null and must remain valid during the call to this function.\n\nSee also\n\nTclTk.Impl.Tcl_IncrRefCount and TclTk.Impl.Tcl_DecrRefCount.\n\n\n\n\n\n","category":"function"},{"location":"develop/#TclTk.Impl.Tcl_IncrRefCount","page":"Internal API for developers","title":"TclTk.Impl.Tcl_IncrRefCount","text":"TclTk.Impl.Tcl_IncrRefCount(objptr) -> objptr\n\nIncrement the reference count of the Tcl object given its pointer and return it.\n\nThis method emulates the Tcl_IncrRefCount macro defined in <tcl.h>.\n\nwarning: Warning\nUnsafe function: object pointer must not be null and must remain valid during the call to this function.\n\nSee also\n\nTclTk.Impl.Tcl_DecrRefCount and TclTk.Impl.Tcl_GetRefCount.\n\n\n\n\n\n","category":"function"},{"location":"develop/#TclTk.Impl.new_list","page":"Internal API for developers","title":"TclTk.Impl.new_list","text":"TclTk.Impl.new_list() -> lstptr\n\nReturn a pointer to a Tcl object storing an empty list.\n\nTclTk.Impl.new_list(f, [interp,] args...) -> lstptr\n\nReturn a pointer to a Tcl object storing a list built by calling f(interp, list, arg) for each arg in args.... Typically, f is TclTk.Impl.unsafe_append_element or TclTk.Impl.unsafe_append_list.\n\nOptional argument interp is a Tcl interpreter that can be used to retrieve the error message in case of failure.\n\nwarning: Warning\nThe returned object is not managed and has a zero reference count. The caller is responsible of taking care of that.\n\n\n\n\n\n","category":"function"},{"location":"develop/#TclTk.Impl.new_object","page":"Internal API for developers","title":"TclTk.Impl.new_object","text":"TclTk.Impl.new_object(x) -> ptr\n\nReturn a pointer to a new Tcl object storing value x. The new object has a reference count of 0.\n\nSee also\n\nTclObj, TclTk.Impl.new_list, TclTk.Impl.Tcl_GetRefCount, TclTk.Impl.Tcl_IncrRefCount, and TclTk.Impl.Tcl_DecrRefCount.\n\n\n\n\n\n","category":"function"},{"location":"develop/#TclTk.Impl.unsafe_append_element","page":"Internal API for developers","title":"TclTk.Impl.unsafe_append_element","text":"TclTk.Impl.unsafe_append_element([interp,] list, item) -> nothing\n\nPrivate method to append item as a single element to the Tcl object list.\n\nOptional argument interp is a pointer to a Tcl interpreter. If interp is specified and non-null, it is used to retrieve the error message in case of failure.\n\nThe following conditions are asserted: list must be writable (i.e., a non-null pointer to a non-shared Tcl object) and item must be readable (i.e., a non-null pointer to a Tcl object).\n\nwarning: Warning\nUnsafe method: list, item, and interp (the latter if non-null) must remain valid during the call to this method (e.g., preserved from being garbage collected).\n\nwarning: Warning\nThe method may throw and the caller is responsible of managing the reference count of item to have it automatically deleted in case of errors if it is fresh object created by new_object(val).\n\nSee also\n\nTclTk.Impl.unsafe_append_list and TclTk.Impl.new_list.\n\n\n\n\n\n","category":"function"},{"location":"develop/#TclTk.Impl.unsafe_append_list","page":"Internal API for developers","title":"TclTk.Impl.unsafe_append_list","text":"TclTk.Impl.unsafe_append_list([interp,] list, iter) -> nothing\n\nPrivate method to concatenate the elements of iter to the end of the Tcl object list.\n\nSee also\n\nTclTk.Impl.unsafe_append_element and TclTk.Impl.new_list.\n\n\n\n\n\n","category":"function"},{"location":"develop/#TclTk.Impl.unsafe_convert","page":"Internal API for developers","title":"TclTk.Impl.unsafe_convert","text":"TclTk.Impl.unsafe_convert(T, objptr) -> val\n\nReturn a value of type T from Tcl object pointer objptr.\n\nThe unsafe prefix on this function indicates that object pointer objptr must not be null and must remain valid during the call to this function.\n\n\n\n\n\n","category":"function"},{"location":"develop/#TclTk.Impl.unsafe_error","page":"Internal API for developers","title":"TclTk.Impl.unsafe_error","text":"TclTk.Impl.unsafe_error(interp)\n\nThrow a Tcl error with a message stored in the result of interp.\n\nwarning: Warning\nThis method is unsafe: the interpreter pointer must be non-null and valid during the call.\n\n\n\n\n\nTclTk.Impl.unsafe_error(interp, mesg)\n\nThrow a Tcl error. The error message is given by the result of interp if it refers to a non-null Tcl interpreter with a non-empty result; otherwise, the error message is mesg.\n\nwarning: Warning\nThis method is unsafe: if non-null, the interpreter pointer must remain valid during the call.\n\nSee also\n\nTclTk.Impl.unsafe_convert and TclTk.Impl.unsafe_result.\n\n\n\n\n\n","category":"function"},{"location":"develop/#TclTk.Impl.unsafe_object_type","page":"Internal API for developers","title":"TclTk.Impl.unsafe_object_type","text":"TclTk.Impl.unsafe_object_type(ptr) -> sym::Symbol\n\nReturn the symbolic type name of Tcl object pointer ptr. The result can be:\n\n:null for a null Tcl object pointer.\n:string for an unspecific object type (i.e., null type pointer null).\n:boolean, :int, :double, :wideInt, :bignum, :bytearray, :list, :bytecode, etc. for an object with a specific internal representation.\n\nwarning: Warning\nThe function is unsafe as ptr may be null and otherwise must be valid for the duration of the call (i.e., protected form being garbage collected).\n\n\n\n\n\n","category":"function"},{"location":"develop/#TclTk.Impl.unsafe_objptr","page":"Internal API for developers","title":"TclTk.Impl.unsafe_objptr","text":"TclTk.Impl.unsafe_objptr(arg) -> objptr\nTclTk.Impl.unsafe_objptr(arg, descr) -> objptr\n\nReturn a pointer to a Tcl object from arg. If arg is an instance of TclObj, pointer(arg) is returned throwing an error if this pointer is null. Otherwise, a new Tcl object is created from arg and the caller is responsible for managing this object so that it is correctly released when no longer in use. In any case, the returned pointer is guaranteed to be non-null but may only remain valid while arg is not garbage collected.\n\nOptional descr provides a description of the argument arg for error messages.\n\nSee also\n\nTclObj, TclTk.Impl.WrappedObject, and TclTk.Impl.new_object,\n\n\n\n\n\n","category":"function"},{"location":"develop/#TclTk.Impl.unsafe_result","page":"Internal API for developers","title":"TclTk.Impl.unsafe_result","text":"TclTk.Impl.unsafe_result(T, interp) -> val\n\nReturn the result of Tcl interpreter interp as a value of type T.\n\nThe function is unsafe: interpreter must be valid (non-null pointer) and remain so during the call to this function.\n\n\n\n\n\n","category":"function"},{"location":"lists/#Lists-of-Tcl-objects","page":"Lists of Tcl objects","title":"Lists of Tcl objects","text":"","category":"section"},{"location":"lists/#Building-lists","page":"Lists of Tcl objects","title":"Building lists","text":"There are two functions to create lists of Tcl objects out of their arguments: TclTk.list and TclTk.concat. For example:\n\njulia> x = TclTk.list(\"a {b c}\", 1, π, (-1, 2, 4))\nTclObj((\"a {b c}\", 1, 3.141592653589793, (-1, 2, 4,),))\n\njulia> y = TclTk.concat(\"a {b c}\", 1, π, (-1, 2, 4))\nTclObj((\"a\", \"b c\", \"1\", \"3.141592653589793\", -1, 2, 4,))\n\n\nAs can be seen in the above examples, TclTk.list follows the behavior of the Tcl list command and each of args.. is an element of the returned list, while TclTk.concat follows the behavior of the Tcl concat command and concatenates the elements of the arguments args... each being considered as a list.","category":"section"},{"location":"lists/#Operations-on-lists","page":"Lists of Tcl objects","title":"Operations on lists","text":"Tcl list objects implement the abstract vector and iterator APIs:\n\njulia> length(x)\n4\n\njulia> length(y)\n7\n\njulia> x[1] # same as first(x)\nTclObj(\"a {b c}\")\n\njulia> first(y) # same as y[1]\nTclObj(\"a\")\n\njulia> x[end] # same as last(x)\nTclObj((-1, 2, 4,))\n\njulia> y[2:end-2]\nTclObj((\"b c\", \"1\", \"3.141592653589793\", -1,))\n\n\nIndexing a Tcl list object with a scalar index can also take a type T to convert the retrieved item to that type:\n\nlist[i, T]   # yields i-th item of list converted to type T\nlist[T, i]   # idem\nlist[i => T] # idem\n\nThis has two advantages: type-stability (the type of the result is inferable) and, compared to convert(T, list[i]), speed (this avoids allocating a mutable TclObj instance).\n\nTo follow Tcl behavior, out of range indices yield missing when indexing a list with a scalar index and are simply ignored when indexing a list with an index range or a vector of indices:\n\njulia> x[0]\nmissing\n\njulia> y[end+1]\nmissing\n\njulia> y[-1:3] # out of bound indices -1 and 0 are ignored\nTclObj((\"a\", \"b c\", \"1\",))\n\n\nA list may be indexed by a vector of Booleans (of same length as the list) to extract a sub-list:\n\njulia> x[length.(x) .== 1]\nTclObj((1, 3.141592653589793,))\n\n\nBase methods push! and append! add elements to the end of a list, the former performs as TclTk.list and the latter performs as TclTk.concat:\n\njulia> push!(TclTk.list(\"a\"), \"b c\")\nTclObj((\"a\", \"b c\",))\n\njulia> append!(TclTk.list(\"a\"), \"b c\")\nTclObj((\"a\", \"b\", \"c\",))\n\n\nBase method delete! deletes element(s) from a list:\n\njulia> z = TclTk.list(\"a {b c}\", 1, π, (-1, 2, 4))\nTclObj((\"a {b c}\", 1, 3.141592653589793, (-1, 2, 4,),))\n\njulia> delete!(z, 3)\nTclObj((\"a {b c}\", 1, (-1, 2, 4,),))\n","category":"section"},{"location":"lists/#Tcl-objects-as-lists","page":"Lists of Tcl objects","title":"Tcl objects as lists","text":"When its content can be converted into a proper list, any Tcl object can be used as a list, that is to say indexed, iterated, etc. In fact, any successful operation on a Tcl object that considers the object as a list convert the internal type of the object into a list type. This is illustrated by the following examples:\n\njulia> z = TclObj(\"a {b c} 3 $(sqrt(π))\")\nTclObj(\"a {b c} 3 1.7724538509055159\")\n\njulia> z.type\n:string\n\njulia> z[2]\nTclObj(\"b c\")\n\njulia> z.type\n:list\n\njulia> z[end-1]\nTclObj(\"3\")\n\njulia> z[end+1]\nmissing\n\n\nThe empty string \"\" is equivalent to an empty list:\n\njulia> q = TclObj(\"\")\nTclObj(\"\")\n\njulia> length(q)\n0\n","category":"section"},{"location":"images/#Tk-images","page":"Tk images","title":"Tk images","text":"Tk images are stored in memory and are meant to be displayed in Tk widgets (usually with the -image option).\n\nnote: Note\nTk extension must have been loaded in the interpreter before using images. This can be done with tk_start.","category":"section"},{"location":"images/#Image-creation","page":"Tk images","title":"Image creation","text":"To build a Tk image, call the constructor TkImage as follows:\n\nTkImage{type}(host=TclInterp(), option => value, ...) -> img\nTkImage{type}(host=TclInterp(), name, option => value, ...) -> img\n\nParameter type is the symbolic image type. Types :bitmap, :pixmap, and :photo are provided by the base Tk package but other packages may implement additional image types.\n\nArgument host is used to infer the Tcl interpreter where lives the image. It is the shared interpreter of the thread if omitted. It can be a widget instance to create the image in the same interpreter as the widget.\n\nOptional argument name is the identifier of the image, it must be a unique command name for the interpreter (the image object can be called as any other Tcl commands); if not specified, name is automatically supplied by Tk. For the returned image, the name is given by img.name. If name is given and corresponds to an existing image in the interpreter, this image is re-wrapped in a TkImage object after applying the configuration changes if any are specified by option => value, .... If the image already exists, it must be of the same type.\n\nAny number of option => value pairs may be specified for setting the initial configurable parameters of the image. As for widgets, option is the name of an image option without the leading hyphen.\n\nCalling the  TkImage constructor with no type parameter is meant to re-wrap an existing image, the image name must be specified in this case:\n\nTkImage(host=TclInterp(), name, option => value, ...) -> img","category":"section"},{"location":"images/#Aliases","page":"Tk images","title":"Aliases","text":"TclTk exports a few aliases for the base Tk image types:\n\nconst TkBitmap = TkImage{:bitmap}\nconst TkPhoto  = TkImage{:photo}\nconst TkPixmap = TkImage{:pixmap}","category":"section"},{"location":"images/#Properties","page":"Tk images","title":"Properties","text":"A Tk image has a number of properties:\n\nimg.inuse yields whether an image is in use in a Tk widget.\nimg.width yields the width of the image in pixels. This is the same as size(img, 1) or img.size[1].\nimg.height yields the height of the image in pixels. This is the same as size(img, 2) or img.size[2].\nimg.size yields the iamge size as (width, height) in pixels. This is the same as size(img) or (img.width, img.height).\nimg.type yields the symbolic type of the image (:bitmap, :pixmap, :photo, etc.).\nimg.name yields the image name in its interpreter.\nimg.interp yields the Tcl interpreter hosting the image.","category":"section"},{"location":"images/#Image-sub-commands","page":"Tk images","title":"Image sub-commands","text":"Like a widget, an image is callable to execute a sub-command for the image. The available sub-commands depend on the image type. For example, for a TkPhoto image, cget and configure are possible sub-commands:\n\njulia> tk_start()\n\njulia> img = TkImage()\nTkPhoto (alias for TkImage{:photo}) name = \"image1\", size = (0, 0)\n\njulia> img(:config)\nTclObj((\"-data {} {} {} {}\", \"-format {} {} {} {}\", \"-metadata {} {} {} {}\", \"-file {} {} {} {}\", \"-gamma {} {} 1 1.0\", \"-height {} {} 0 0\", \"-palette {} {} {} {}\", \"-width {} {} 0 0\",))\n\njulia> img(:cget, \"-width\")\nTclObj(\"0\")\n\njulia> img(Int, :cget, \"-height\")\n0\n\n\nPublic functions TclTk.cget and TclTk.configure are applicable to an image instance. For example:\n\njulia> tk_start()\n\njulia> img = TkImage()\nTkPhoto (alias for TkImage{:photo}) name = \"image1\", size = (0, 0)\n\njulia> TclTk.configure(img)\nTclObj((\"-data {} {} {} {}\", \"-format {} {} {} {}\", \"-metadata {} {} {} {}\", \"-file {} {} {} {}\", \"-gamma {} {} 1 1.0\", \"-height {} {} 0 0\", \"-palette {} {} {} {}\", \"-width {} {} 0 0\",))\n\njulia> TclTk.cget(Int, img, \"width\") # no hyphen here\n0\n","category":"section"},{"location":"images/#Loading-and-storing-pixels","page":"Tk images","title":"Loading and storing pixels","text":"A Tk photo image can be indexed as a 2-dimensional array to access its pixels. Pixel indices are 1-based as is usually the case in Julia arrays. Following the convention in Tk, the first and second axes respectively correspond to the width and height of the image.\n\nFor example:\n\nA = img[xroi, yroi]\n\nyields an array A with a copy of the pixels of the image img in the region of interest (ROI) defined by xroi and yroi, two unit ranges or colons. The full image is obtained by img[:,:]. The element type of the result depend on the image pixel type, most certainly RGBA{N0f8}, that is red, green, blue, and alpha each encoded in a UInt8.\n\nAs for indexing arrays, if one of xroi or yroi is a scalar index, the extracted ROI is a vector of pixels, while if both xroi or yroi are scalar indices, the extracted ROI is a single pixel.\n\nStoring pixel values is as simple as:\n\nimg[xroi, yroi] = A\n\nwhich performs pixel value conversion as needed. When the content of a Tk image is modified, it is automatically redrawn in the widgets that use it.","category":"section"},{"location":"interpreters/#Tcl-interpreters","page":"Tcl interpreters","title":"Tcl interpreters","text":"","category":"section"},{"location":"interpreters/#Managing-interpreters","page":"Tcl interpreters","title":"Managing interpreters","text":"Tcl scripts and commands are executed by a Tcl interpreter which is an instance of TclInterp in TclTk. An application may have multiple Tcl interpreters but a given interpreter must only be used in the thread where the interpreter was created otherwise Tcl would panic (thus aborting the program). To prevent this, TclTk throws an exception if such an attempt is made. Furthermore, TclTk maintains a cached list of so-called shared interpreters, one for each thread, to used as the default interpreter for a given tread. These shared interpreter are only created when needed. The shared interpreter of the calling thread can be retrieved by calling the TclInterp constructor with no argument of with the symbol :shared:\n\njulia> interp = TclInterp()\nTcl interpreter (address: 0x000000002274e130, threadid: 1)\n\njulia> interp = TclInterp(:shared)\nTcl interpreter (address: 0x000000002274e130, threadid: 1)\n\n\nTo create a private Tcl interpreter, call the TclInterp constructor with the symbol :private:\n\njulia> interp = TclInterp(:private)\nTcl interpreter (address: 0x0000000023461410, threadid: 1)\n\n\nThe resources associated with a Tcl interpreter are automatically released when the TclInterp object is no longer referenced (that is garbage collected).","category":"section"},{"location":"interpreters/#Evaluation-of-commands","page":"Tcl interpreters","title":"Evaluation of commands","text":"Execution of a Tcl command may be done in three different ways:\n\nTclTk.exec(T=TclObj, interp=TclInterp(), args...)\ninterp.exec(T=TclObj, args...)\ninterp(T=TclObj, args...)\n\nwhich execute the command specified by args... with the Tcl interpreter interp and yield a result of type T (a Tcl object by default). Any key => val pair in args... is converted in the pair of arguments -key and val in the command list (note the hyphen before the key name). Otherwise, each of args... is a token of the command. The specific handling of pairs is very useful for specifying options for widgets.\n\nThe execution of a Tcl command stores a result (or an error message) in the interpreter and returns a status. The behavior of TclTk.exec, or equivalent, depends on the type T of the expected result:\n\nIf T is TclStatus, the status of the evaluation is returned and the command result may be retrieved by calling TclTk.getresult, by interp.result(...), or by interp[...].\nIf T is Nothing, an exception is thrown if the status is not TCL_OK and nothing is returned otherwise (i.e., the result of the command is ignored).\nOtherwise, an exception is thrown if the status is not TCL_OK and the result of the command is returned as a value of type T otherwise.\n\nWith TclTk.exec, the shared interpreter of the thread is used by default.","category":"section"},{"location":"interpreters/#Evaluation-of-scripts","page":"Tcl interpreters","title":"Evaluation of scripts","text":"Evaluation of Tcl scripts may be done in two different ways:\n\nTclTk.eval(T=TclObj, interp=TclInterp(), args...)\ninterp.eval(T=TclObj, args...)\n\nwhich concatenate args... (as done by the TclTk.concat function) in the form of script evaluated by the Tcl interpreter interp and yield the result of the script as a value of type T (a Tcl object by default). In case of error, the behavior depends on T as for the execution of a Tcl command described above. With TclTk.eval, the shared interpreter of the thread is used by default.","category":"section"},{"location":"interpreters/#Interpreter-result","page":"Tcl interpreters","title":"Interpreter result","text":"A Tcl interpreter stores the result of the last executed command or of the last evaluated script or the last error message. Indexing an interpreter, say interp, without anything or with a type T, that is as interp[] or interp[T], give access to the interpreter result, converted to type T (TclObj by default).\n\nFor example:\n\njulia> interp = TclInterp()\nTcl interpreter (address: 0x00000000260af720, threadid: 1)\n\njulia> interp[] = 43 # set interpreter's result\n43\n\njulia> interp[] # retrieve interpreter's result\nTclObj(43)\n\njulia> interp[Int] # retrieve interpreter's result as an `Int`\n43\n\njulia> interp[String] # retrieve interpreter's result as a `String`\n\"43\"\n\n\nAccessing and mutating the result of an interpreter is done by methods TclTk.getresult(T=TclObj, interp=TclInterp()) and TclTk.setresult!(interp=TclInterp(), value) which, if no interpreter is specified, apply to the shared interpreter of the thread.","category":"section"},{"location":"interpreters/#Global-variables","page":"Tcl interpreters","title":"Global variables","text":"A Tcl interpreter may also be indexed by a Tcl variable and an optional leading type T to access to global variables stored by the interpreter:\n\ninterp[name]          # get value of global variable\ninterp[T, name]       # idem but value is converted to type `T`\ninterp[name] = value  # set value of global variable\nhaskey(interp, name)  # yield whether global variable exists\ndelete!(interp, name) # delete global variable\ninterp[name] = unset  # idem\n\nAbove unset is the singleton provided by the UnsetIndex package and exported by the Tcl package\n\nUnder the hood, accessing and mutating the value of a global variable is done by the methods TclTk.getvar(T=TclObj, interp=TclInterp(), name) and TclTk.setvar!(Nothing, interp=TclInterp(), name, value), checking for the existence of a global variable is done by the method TclTk.exists(interp=TclInterp(), name), and deleting a global variable is done by the method TclTk.unsetvar!(interp=TclInterp(), name). All these methods apply to the shared interpreter of the thread if no interpreter is specified.","category":"section"},{"location":"interpreters/#Properties","page":"Tcl interpreters","title":"Properties","text":"A Tcl interpreter, say interp::TclInterp has a number of properties:\n\ninterp.list(args...) is a shortcut for TclTk.list(interp, args...) to build a list of Tcl objects, one for each of args.... In this context, the interpreter is only used to report errors if any, the returned list is not linked to the interpreter.\ninterp.concat(args...) is a shortcut for TclTk.concat(interp, args...) to concatenate arguments args... to form a list of Tcl objects. In this context, the interpreter is only used to report errors if any, the returned list is not linked to the interpreter.\ninterp.exec(T=TclObj, args...) is a shortcut for TclTk.exec(T, interp, args...) to execute a Tcl command with the interpreter and return a result of type T, a Tcl object by default. The first of args... is the Tcl command while the remaining args... are the arguments (or tokens) of the command.\ninterp.eval(T=TclObj, args...) is a shortcut for TclTk.eval(T, interp, args...) to evaluate the concatenation of args... as a Tcl script with the interpreter and return a result of type T, a Tcl object by default.\ninterp.result(T=TclObj) is a shortcut for TclTk.getresult(T, interp) and the same as interp[T] to get the result stored by the interpreter as a value of type T. Depending on the last thing done by the interpreter, its result may be: empty, the result of the last command evaluated by the interpreter, or the error message of the last error occurring in the interpreter. See TclTk.setresult! for setting the result of a Tcl interpreter.\ninterp.threadid yields the identifier of the thread where the interpreter lives.\ninterp.ptr yields the pointer to the Tcl interpreter, this is the same as pointer(interrp). Using this property to call a C function is unsafe (the object must be preserved from being garbage collected).","category":"section"},{"location":"objects/#Tcl-objects","page":"Tcl objects","title":"Tcl objects","text":"Anything in Tcl can be equivalently expressed as a string but, for efficiency, everything is stored in Tcl objects. Such objects can be manipulated directly in Julia, as instances of TclObj, and may be converted to Julia values (strings, integers, floats, or vectors of these) as needed. By avoiding systematic string conversion, faster communication with Tcl/Tk is achieved.","category":"section"},{"location":"objects/#Creation-of-Tcl-objects","page":"Tcl objects","title":"Creation of Tcl objects","text":"Many functions of TclTk may return a Tcl object. But Tcl objects may be explicitly created by calling the TclObj constructor:\n\nobj = TclObj(val)\n\nwhich yields a Tcl object storing the value val. The initial type of the Tcl object, given by obj.type, depends on the type of val:\n\nA string, symbol, or character is stored as a Tcl :string.\nA Boolean or integer is stored as a Tcl :int or :wideInt.\nA non-integer real is stored as a Tcl :double.\nA dense vector of bytes (UInt8) is stored as a Tcl :bytearray.\nA tuple is stored as a Tcl :list.\nA Tcl object is returned unchanged. Call copy to have an independent copy.\n\nIf the content of a Tcl object is valid as a list (in this respect a Tcl :double object is also a single element list), the object may be indexed, elements may be added, deleted, etc.","category":"section"},{"location":"objects/#Properties-of-Tcl-objects","page":"Tcl objects","title":"Properties of Tcl objects","text":"Tcl objects have the following properties:\n\nobj.refcnt yields the reference count of obj. If obj.refcnt > 1, the object is shared and must be copied before being modified.\nobj.ptr yields the pointer to the Tcl object, this is the same as pointer(obj). Using this property to call a C function is unsafe (the object must be preserved from being garbage collected).\nobj.type yields the current internal type of obj as a symbol. This type may change depending on how the object is used by Tcl. For example, after having evaluated a script in a Tcl string object, the object internal state becomes :bytecode to reflect that it now stores compiled byte code.","category":"section"},{"location":"objects/#Conversion-of-Tcl-objects","page":"Tcl objects","title":"Conversion of Tcl objects","text":"Simply call convert(T, obj) to get a value of type T from a Tcl object obj. For example:\n\njulia> x = TclObj(\"1.234\")\nTclObj(\"1.234\")\n\njulia> x.type\n:string\n\njulia> convert(Int, x)\nERROR: Tcl/Tk error: cannot convert Tcl object to `Int64` value\n…\n\njulia> convert(Float32, x)\n1.234f0\n\njulia> convert(Bool, TclObj(\"yes\")) # \"yes\", \"on\", and \"true\" are considered as true in Tcl\ntrue\n\njulia> convert(Bool, TclObj(\"off\")) # \"no\", \"off\", and \"false\" are considered as true in Tcl\nfalse\n\n\nThe above error shows that the conversion must make sense. However, the content of a Tcl object may always be converted into a string by calling convert(String, obj), string(obj), or String(obj) which all yield a copy of this string. For example:\n\njulia> x = TclObj(1.234)\nTclObj(1.234)\n\njulia> x.type\n:double\n\njulia> string(x)\n\"1.234\"\n\njulia> convert(String, x)\n\"1.234\"\n\n\nConversion of a Tcl object to a vector is also supported. For basic vector types (Vector or Memory), conversion by the constructor is also implemented. If the element type is UInt8, a vector of bytes representing the raw content of the Tcl object is returned. For other element types, the Tcl object is treated as a list whose elements are converted to the element type. For example:\n\njulia> t = (false, true, -1, 12)\n(false, true, -1, 12)\n\njulia> x = TclObj(t)\nTclObj((0, 1, -1, 12,))\n\njulia> Vector{Int16}(x)\n4-element Vector{Int16}:\n  0\n  1\n -1\n 12\n\njulia> Vector{String}(x)\n4-element Vector{String}:\n \"0\"\n \"1\"\n \"-1\"\n \"12\"\n\njulia> v = Vector{UInt8}(x) # conversion to bytes yields raw object content...\n9-element Vector{UInt8}:\n 0x30\n 0x20\n 0x31\n 0x20\n 0x2d\n 0x31\n 0x20\n 0x31\n 0x32\n\njulia> s = \"$x\"\n\"0 1 -1 12\"\n\njulia> codeunits(s) # ... which is like the string representation in this case\n9-element Base.CodeUnits{UInt8, String}:\n 0x30\n 0x20\n 0x31\n 0x20\n 0x2d\n 0x31\n 0x20\n 0x31\n 0x32\n\njulia> Memory{Float64}(TclObj(1.25))\n1-element Memory{Float64}:\n 1.25\n\njulia> Memory{UInt8}(TclObj(1.25))\n4-element Memory{UInt8}:\n 0x31\n 0x2e\n 0x32\n 0x35\n\njulia> codeunits(\"1.25\")\n4-element Base.CodeUnits{UInt8, String}:\n 0x31\n 0x2e\n 0x32\n 0x35\n\njulia> b = TclObj([0x01,0xff,0x00,0x3c]) # an array of raw bytes...\nTclObj(UInt8[0x01, 0xff, 0x00, 0x3c])\n\njulia> Vector{UInt8}(b) # ... is stored unchanged by the Tcl object\n4-element Vector{UInt8}:\n 0x01\n 0xff\n 0x00\n 0x3c\n\n\nAs shown above, conversion of a Tcl object to an array of bytes is similar to the code units of the string representation of the object except for :bytearray Tcl objects where the raw byte values are preserved.","category":"section"},{"location":"objects/#Comparisons-with-Tcl-objects","page":"Tcl objects","title":"Comparisons with Tcl objects","text":"Base methods isequal(a, b) and a == b yield whether Tcl objects a and b have the same value. Since any kind of Tcl object is equivalent to a string, Tcl objects may also be compared to strings and symbols for equality:\n\njulia> a = TclObj(1.234)\nTclObj(1.234)\n\njulia> b = TclObj(string(a))\nTclObj(\"1.234\")\n\njulia> a.type\n:double\n\njulia> b.type\n:string\n\njulia> a == b\ntrue\n\njulia> a == \"1.234\"\ntrue\n\njulia> b == \"1.234\"\ntrue\n\njulia> c = TclObj(\"green\")\nTclObj(\"green\")\n\njulia> c == :green\ntrue\n\njulia> c == \"GREEN\"\nfalse\n","category":"section"},{"location":"widgets/#Widgets","page":"Widgets","title":"Widgets","text":"","category":"section"},{"location":"widgets/#Widget-creation","page":"Widgets","title":"Widget creation","text":"","category":"section"},{"location":"widgets/#Top-level-widgets","page":"Widgets","title":"Top-level widgets","text":"A top-level or a menu widget are created by:\n\ntop = TkToplevel(interp=TclInterp(), [path,] option => value, ...)\nmenu = TkMenu(interp=TclInterp(), [path,] option => value, ...)\n\nwhere interp is the interpreter where to create the widget (the shared interpreter of the thread by default), path is a string like \".top\" or \".menu\" (it must start with a dot and have no other dots) and option => value, ... denotes any number of settings with option an option name (a string or a symbol without a leading hyphen) and value the option value. The path argument is optional; if omitted, a widget path is automatically generated in the form \".$(pfx)$(num)\" where pfx is a short prefix specific to the widget class and num is a unique number.\n\nThe widget path (given by w.path for a widget w) is also the name of the Tcl command implementing the widget behavior and is used for any reference to the widget.\n\nFor example:\n\njulia> top = TkToplevel(:relief => :sunken, :borderwidth => 5, :background => :cyan)\nTkToplevel(\".top3\")\n\n\nSymbols like :relief and :sunken can also be specified as literal strings (or as Tcl objects but this is less common): :relief => :sunken, \"relief\" => \"sunken\", or :relief => \"sunken\" are all the same.","category":"section"},{"location":"widgets/#Other-widgets","page":"Widgets","title":"Other widgets","text":"Non-top level widgets have a parent (a top-level widget, a frame, etc.) which must be provided to the constructor. For example, a label is created by something like:\n\nlab = TkLabel(parent, [child,] option => value, ...)\n\nwhere child is the path of the widget relative to its parent, it must have no dots. The relative path, child, is optional and is automatically generated if omitted.\n\nThe path of the widget is the concatenation of its parent path and the widget relative path with a dot separator. The widget path is given by the property w.path for a widget w. The widget path is unique for a given interpreter, if a widget constructor is called with a path of an existing widget, a Julia object wrapping the same Tk widget is returned. However, the constructor must correspond to the class of the existing widget. To relax this, a widget instance can be built for an existing widget by calling the abstract constructor TkWidget:\n\nw = TkWidget(interp=TclInterp(), path)\nw = TkWidget(interp=TclInterp(), parent, child)\n\nThe latter case is equivalent to have path = \"$(parent).$(child)\" in the former case.","category":"section"},{"location":"widgets/#Widget-sub-commands","page":"Widgets","title":"Widget sub-commands","text":"Tk widgets may be invoked to execute sub-commands (the list of which depend on the widget type). There are different two equivalent ways to call a widget sub-command:\n\nTclTk.exec(T=TclObj, widget, subcmd, args...)\nwidget(T=TclObj, subcmd, args...)\n\nwhere widget is a widget instance, optional leading argument T is the expected type of the result (a Tcl object by default), subcmd is the sub-command name (a string, a symbol, or a Tcl object) and args... are the arguments of the sub-command. For example, assuming btn is a button widget, retrieving the associated text can be done by one of:\n\nTclTk.exec(String, btn, :cget, \"-text\")\nbtn(String, :cget, \"-text\")\n\nwarning: Warning\nAnother possibility could be to evaluate a Tcl script as in:TclTk.eval(String, \"$btn cget -text\")However, this is not recommended as TclTk.eval in this example will use the shared interpreter of the thread whereas the interpreter which may not be the one where lives the widget. This is avoided by the other ways to execute a sub-command.","category":"section"},{"location":"widgets/#Geometry-managers","page":"Widgets","title":"Geometry managers","text":"Non-top level widgets must be managed by a geometry manager to become visible. Tk provides 3 different geometry managers to organize widgets within a so-called container widget (their parent by default):\n\nThe placer geometry manager, via the TclTk.place function, provides simple fixed placement of widgets inside their container.\nThe packer geometry manager, via the TclTk.pack function, packs the widgets in order against the edges of their container.\nThe grid geometry manager, via the TclTk.grid function, arranges widgets in rows and columns inside their container.\n\nThese geometry managers take a variable number of arguments, one of which must be a widget and all widget arguments must live in the same interpreter.\n\nFor example packing a label and a button one above the other in a top-level window can be done by:\n\ninterp = tk_start()\ntop = TkToplevel(interp, :background => \"darkseagreen\")\nlab = TkLabel(top, :text => \"Some label\", :background => \"lightblue\")\nbtn = TkButton(top, :text => \"Click me\", :background => \"goldenrod\", :command => \"puts {Hello world!}\")\nTclTk.pack(Nothing, btn, lab, :side => :bottom, :padx => 90, :pady => 5)\ninterp(Nothing, :wm, :title, top, \"Tk `pack` example\")\n\nwhich gives:\n\n(Image: Tk pack example)","category":"section"},{"location":"widgets/#Widget-configuration","page":"Widgets","title":"Widget configuration","text":"","category":"section"},{"location":"widgets/#Configuration-at-creation","page":"Widgets","title":"Configuration at creation","text":"For the following examples, we create a top-level window top with embedded label lab and button btn widgets as follows:\n\nusing TclTk\ntk_start()\ntop = TkToplevel()\nlab = TkLabel(top, :text => \"Some label\", :background => \"lightblue\")\nbtn = TkButton(top, :text => \"Please push me...\", :command => \"puts {Button pushed!}\")\nTclTk.pack(Nothing, btn, :side => :top, :padx => 70, :pady => 5)\n\nThis shows how option => value pairs can be used at widget creation to set some configurable options.","category":"section"},{"location":"widgets/#The-cget-sub-command","page":"Widgets","title":"The cget sub-command","text":"Configuration options of btn can be queried by the cget sub-command as in the following examples:\n\njulia> TclTk.exec(btn, :cget, \"-text\") # each argument is a token\nTclObj(\"Please push me...\")\n\njulia> btn(:cget, \"-text\") # shortcut for the above example\nTclObj(\"Please push me...\")\n\njulia> TclTk.cget(btn, :text) # option name without hyphen\nTclObj(\"Please push me...\")\n\njulia> btn[:text] # option name without hyphen\nTclObj(\"Please push me...\")\n\n\nAs can be seen, any of these statements yields a Tcl object whose content is the value of the -text option. Which syntax is preferred is a matter of taste.\n\nAn optional Julia type may be specified to convert the value of the Tcl object:\n\njulia> TclTk.exec(String, btn, :cget, \"-text\") # each argument is a token\n\"Please push me...\"\n\njulia> btn(String, :cget, \"-text\") # shortcut for the above example\n\"Please push me...\"\n\njulia> TclTk.cget(String, btn, :text) # option name without hyphen\n\"Please push me...\"\n\njulia> btn[String, :text]\n\"Please push me...\"\n\njulia> btn[:text, String]\n\"Please push me...\"\n\njulia> btn[:text => String]\n\"Please push me...\"\n\n\nSpecifying a Julia type for the expected result is a bit faster than converting the result to this type as with:\n\njulia> String(btn[:text])\n\"Please push me...\"\n","category":"section"},{"location":"widgets/#The-configure-sub-command","page":"Widgets","title":"The configure sub-command","text":"For an existing widget, re-configuration can be done by via the configure sub-command (often abbreviated to config) of the widget:\n\njulia> TclTk.exec(btn, :config, :background => \"darkseagreen\")\nTclObj(\"\")\n\n\nor equivalently:\n\njulia> btn(:config, :background => \"darkseagreen\")\nTclObj(\"\")\n\n\nAny number of option settings can be specified for configure sub-command but since configuring one or more options yields an empty result, Nothing may be specified as the expected result type:\n\njulia> btn(Nothing, :config, :foreground => \"firebrick\", :background => \"darkseagreen\")\n\n\nAs a shortcut, changing a single option can also be done by the setindex! method:\n\njulia> btn[:background] = \"darkseagreen\"\n\"darkseagreen\"\n\n\nWithout any option => value pairs, the configure sub-command yields a list of all current settings:\n\njulia> btn(:config)\nTclObj(((\"-activebackground\", \"activeBackground\", \"Foreground\", \"#ececec\", \"#ececec\",), (\"-activeforeground\", \"activeForeground\", \"Background\", \"#000000\", \"#000000\",), (\"-anchor\", \"anchor\", \"Anchor\", \"center\", \"center\",), (\"-background\", \"background\", \"Background\", \"#d9d9d9\", \"darkseagreen\",), (\"-bd\", \"-borderwidth\",), (\"-bg\", \"-background\",), (\"-bitmap\", \"bitmap\", \"Bitmap\", \"\", \"\",), (\"-borderwidth\", \"borderWidth\", \"BorderWidth\", 1, 1,), (\"-command\", \"command\", \"Command\", \"\", \"puts {Button pushed!}\",), (\"-compound\", \"compound\", \"Compound\", \"none\", \"none\",), (\"-cursor\", \"cursor\", \"Cursor\", \"\", \"\",), (\"-default\", \"default\", \"Default\", \"disabled\", \"disabled\",), (\"-disabledforeground\", \"disabledForeground\", \"DisabledForeground\", \"#a3a3a3\", \"#a3a3a3\",), (\"-fg\", \"-foreground\",), (\"-font\", \"font\", \"Font\", \"TkDefaultFont\", \"TkDefaultFont\",), (\"-foreground\", \"foreground\", \"Foreground\", \"#000000\", \"firebrick\",), (\"-height\", \"height\", \"Height\", 0, 0,), (\"-highlightbackground\", \"highlightBackground\", \"HighlightBackground\", \"#d9d9d9\", \"#d9d9d9\",), (\"-highlightcolor\", \"highlightColor\", \"HighlightColor\", \"#000000\", \"#000000\",), (\"-highlightthickness\", \"highlightThickness\", \"HighlightThickness\", 1, 1,), (\"-image\", \"image\", \"Image\", \"\", \"\",), (\"-justify\", \"justify\", \"Justify\", \"center\", \"center\",), (\"-overrelief\", \"overRelief\", \"OverRelief\", \"\", \"\",), (\"-padx\", \"padX\", \"Pad\", \"3m\", \"3m\",), (\"-pady\", \"padY\", \"Pad\", \"1m\", \"1m\",), (\"-relief\", \"relief\", \"Relief\", \"raised\", \"raised\",), (\"-repeatdelay\", \"repeatDelay\", \"RepeatDelay\", 0, 0,), (\"-repeatinterval\", \"repeatInterval\", \"RepeatInterval\", 0, 0,), (\"-state\", \"state\", \"State\", \"normal\", \"normal\",), (\"-takefocus\", \"takeFocus\", \"TakeFocus\", \"\", \"\",), (\"-text\", \"text\", \"Text\", \"\", \"Please push me...\",), (\"-textvariable\", \"textVariable\", \"Variable\", \"\", \"\",), (\"-underline\", \"underline\", \"Underline\", \"\", \"\",), (\"-width\", \"width\", \"Width\", 0, 0,), (\"-wraplength\", \"wrapLength\", \"WrapLength\", 0, 0,),))\n","category":"section"},{"location":"public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public/#Objects","page":"Public API","title":"Objects","text":"","category":"section"},{"location":"public/#Interpreters","page":"Public API","title":"Interpreters","text":"","category":"section"},{"location":"public/#Status-and-exceptions","page":"Public API","title":"Status and exceptions","text":"","category":"section"},{"location":"public/#Variables","page":"Public API","title":"Variables","text":"","category":"section"},{"location":"public/#Callbacks","page":"Public API","title":"Callbacks","text":"TclTk.Callback","category":"section"},{"location":"public/#Events","page":"Public API","title":"Events","text":"","category":"section"},{"location":"public/#Widgets","page":"Public API","title":"Widgets","text":"","category":"section"},{"location":"public/#Geometry-managers","page":"Public API","title":"Geometry managers","text":"","category":"section"},{"location":"public/#Images","page":"Public API","title":"Images","text":"","category":"section"},{"location":"public/#TclTk.Impl.TclObj","page":"Public API","title":"TclTk.Impl.TclObj","text":"TclObj(val) -> obj\n\nReturn a Tcl object storing value val. The initial type of the Tcl object, given by obj.type, depends on the type of val:\n\nA string, symbol, or character is stored as a Tcl :string.\nA Boolean or integer is stored as a Tcl :int or :wideInt.\nA non-integer real is stored as a Tcl :double.\nA dense vector of bytes (UInt8) is stored as a Tcl :bytearray.\nA tuple is stored as a Tcl :list.\nA Tcl object is returned unchanged. Call copy to have an independent copy.\n\nIf the content of a Tcl object is valid as a list, the object may be indexed, elements may be added, deleted, etc.\n\nProperties\n\nTcl objects have the following properties:\n\nobj.refcnt yields the reference count of obj. If obj.refcnt > 1, the object is shared and must be copied before being modified.\nobj.ptr yields the pointer to the Tcl object, this is the same as pointer(obj).\nobj.type yields the current internal type of obj as a symbol. This type may change depending on how the object is used by Tcl. For example, after having evaluated a script in a Tcl string object, the object internal state becomes :bytecode to reflect that it now stores compiled byte code.\n\nConversion\n\nCall convert(T, obj) to get a value of type T from Tcl object obj. The content of a Tcl object may always be converted into a string by calling convert(String, obj), string(obj), or String(obj) which all yield a copy of this string.\n\nSee also\n\nTclTk.list or TclTk.concat for building Tcl objects to efficiently store arguments of Tcl commands.\n\nMethods TclTk.Impl.new_object and TclTk.Impl.unsafe_convert may be extended to convert other types of value to Tcl object.\n\n\n\n\n\n","category":"type"},{"location":"public/#TclTk.Impl.concat","page":"Public API","title":"TclTk.Impl.concat","text":"TclTk.concat(args...) -> lst\ninterp.concat(args...) -> lst\n\nBuild a list of Tcl objects obtained by concatenating the elements of the arguments arg... each being considered as a list. This mimics the behavior of the Tcl concat command.\n\nIn the second above example, interp is a Tcl interpreter used to retrieve a more informative error message in case of error.\n\nSee also\n\nTclTk.list, TclTk.eval, TclObj, and TclInterp.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.list","page":"Public API","title":"TclTk.Impl.list","text":" TclTk.list(args...) -> lst\n interp.list(args...) -> lst\n\nBuild a list lst of Tcl objects such that each of args... is a single element of lst. This mimics the behavior of the Tcl list command.\n\nIn the second above example, interp is a Tcl interpreter used to retrieve an error message in case of failure.\n\nSee also\n\nTclTk.concat, TclTk.eval, TclObj, and TclInterp.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.TclInterp","page":"Public API","title":"TclTk.Impl.TclInterp","text":"interp = TclInterp()\ninterp = TclInterp(:shared | :private)\n\nReturn a Tcl interpreter. If argument is :shared or unspecified, an interpreter shared by all tasks running on the current thread is returned. If argument is :private, a new private interpreter is created.\n\nwarning: Warning\nA Tcl interpreter can only be used by the thread where it was created.\n\nThe resulting object can be used as a function to execute a Tcl command. For example:\n\njulia> interp(:set, :x, 42)\nTclObj(42)\n\nThe result of the command is returned as a Tcl object storing the value 42. See TclTk.exec for more details about execution of Tcl commands.\n\nTo evaluate a Tcl script with the interpreter, call interp.eval(args...). The above example can also be done by:\n\njulia> interp.eval(\"set x 42\")\nTclObj(\"42\")\n\nwhose result is a Tcl object storing the string \"42\". See method TclTk.eval for more details about script evaluation.\n\nThe interp object can also be indexed as an array to access global Tcl variables (the variable name can be specified as a string or as a symbol):\n\ninterp[\"x\"]          # yields value of variable \"x\"\ninterp[:tcl_version] # yields version of Tcl\ninterp[:x] = 33      # set the value of \"x\" and yields its value\n\nThe Tcl interpreter is initialized and will be deleted when no longer in use. If Tk has been properly installed, then:\n\ninterp.eval(\"package require Tk\")\n\nshould load Tk extension and create the \".\" toplevel Tk window. But see tk_start method to load Tk.\n\n\n\n\n\n","category":"type"},{"location":"public/#TclTk.eval","page":"Public API","title":"TclTk.eval","text":"TclTk.eval(T=TclObj, interp=TclInterp(), args...) -> res::T\ninterp.eval(T=TclObj, args...) -> res::T\n\nConcatenate arguments args... into a list, evaluate this list as a Tcl script with interpreter interp, and return a value of type T.Any key => val pair in args... is converted in the pair of arguments -key and val in the script list (note the hyphen before the key name).\n\nThe evaluation of a Tcl script stores a result (or an error message) in the interpreter and returns a status. The behavior of TclTk.eval depend on the type T of the expected result:\n\nIf T is TclStatus, the status of the evaluation is returned and the script result may be retrieved by calling TclTk.getresult or via interp.result(...).\nIf T is Nothing, an exception is thrown if the status is not TCL_OK and nothing is returned otherwise (i.e., the result of the script is ignored).\nOtherwise, an exception is thrown if the status is not TCL_OK and the result of the script is returned as a value of type T otherwise.\n\nSee also\n\nSee TclTk.concat for the rules to concatenate arguments into a list (apart from the accounting of pairs).\n\nSee TclTk.exec for another way to execute a Tcl command where each of args... is considered as a distinct command argument.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.exec","page":"Public API","title":"TclTk.Impl.exec","text":"TclTk.exec(T=TclObj, interp=TclInterp(), args...) -> res::T\ninterp.exec(T=TclObj, args...) -> res::T\ninterp(T=TclObj, args...) -> res::T\n\nMake a list out of the arguments args..., evaluate this list as a Tcl command with interpreter interp, and return a value of type T. Any key => val pair in args... is converted in the pair of arguments -key and val in the command list (note the hyphen before the key name).\n\nThe evaluation of a Tcl command stores a result (or an error message) in the interpreter and returns a status. The behavior of TclTk.exec depends on the type T of the expected result:\n\nIf T is TclStatus, the status of the evaluation is returned and the command result may be retrieved by calling TclTk.getresult or via interp.result(...).\nIf T is Nothing, an exception is thrown if the status is not TCL_OK and nothing is returned otherwise (i.e., the result of the command is ignored).\nOtherwise, an exception is thrown if the status is not TCL_OK and the result of the command is returned as a value of type T otherwise.\n\nSee also\n\nSee TclTk.list for the rules to build a list (apart from the accounting of pairs).\n\nSee TclTk.eval for another way to evaluate a Tcl script. The difference with TclTk.eval is that each input argument is interpreted as a different token of the Tcl command.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.getresult","page":"Public API","title":"TclTk.Impl.getresult","text":"interp[] -> obj::TclObj\ninterp.result() -> obj::TclObj\nTclTk.getresult() -> obj::TclObj\nTclTk.getresult(interp) -> obj::TclObj\n\ninterp.result(T) -> val::T\nTclTk.getresult(T) -> val::T\nTclTk.getresult(T, interp) -> val::T\nTclTk.getresult(interp, T) -> val::T\n\nRetrieve the result of interpreter interp as a value of type T or as a Tacl object if T is not specified. TclTk.getresult returns the result of the shared interpreter of the thread.\n\nSee also\n\nTclInterp and TclObj.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.setresult!","page":"Public API","title":"TclTk.Impl.setresult!","text":"TclTk.setresult!(interp = TclInterp(), value) -> nothing\n\nSet the result stored in Tcl interpreter interp with value.\n\nIf not specified, interp is the shared interpreter of the calling thread.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.quote_string","page":"Public API","title":"TclTk.Impl.quote_string","text":"TclTk.quote_string(str)\n\nReturn string str a valid Tcl string surrounded by double quotes that can be directly inserted in Tcl scripts.\n\nThis is similar to escape_string but specialized to represent a valid Tcl string surrounded by double quotes in a script.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.isactive","page":"Public API","title":"TclTk.Impl.isactive","text":"TclTk.isactive(interp=TclInterp()) -> bool::Bool\n\nReturn whether Tcl interpreter interp is active, i.e. is currently executing some script.\n\nSee also\n\nTclInterp, TclTk.issafe, and TclTk.isdeleted.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.isdeleted","page":"Public API","title":"TclTk.Impl.isdeleted","text":"TclTk.isdeleted(interp=TclInterp()) -> bool::Bool\n\nReturn whether Tcl interpreter interp has been deleted.\n\nSee also\n\nTclInterp, TclTk.isactive, and TclTk.issafe.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.issafe","page":"Public API","title":"TclTk.Impl.issafe","text":"TclTk.issafe(interp=TclInterp()) -> bool::Bool\n\nReturn whether Tcl interpreter interp is safe, i.e. is suitable for executing untrusted code.\n\nSee also\n\nTclInterp, TclTk.isactive, and TclTk.isdeleted.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.TclStatus","page":"Public API","title":"TclTk.Impl.TclStatus","text":"TclStatus\n\nType of result returned by evaluating Tcl scripts or commands. Possible values are:\n\nTCL_OK: Command completed normally; the interpreter's result contains the command's result.\nTCL_ERROR: The command couldn't be completed successfully; the interpreter's result describes what went wrong.\nTCL_RETURN: The command requests that the current function return; the interpreter's result contains the function's return value.\nTCL_BREAK: The command requests that the innermost loop be exited; the interpreter's result is meaningless.\nTCL_CONTINUE: Go on to the next iteration of the current loop; the interpreter's result is meaningless.\n\n\n\n\n\n","category":"type"},{"location":"public/#TclTk.Impl.TclError","page":"Public API","title":"TclTk.Impl.TclError","text":"TclError(args...)\nTclError(interp::TclInterp)\n\nReturn a TclError exception with error message given by string(args...) or taken from the last result in interpreter interp.\n\n\n\n\n\n","category":"type"},{"location":"public/#TclTk.Impl.tcl_error","page":"Public API","title":"TclTk.Impl.tcl_error","text":"tcl_error(args...)\ntcl_error(interp::TclInterp)\n\nThrow a TclError exception with error message given by string(args...) or taken from the last result in interpreter interp.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.exists","page":"Public API","title":"TclTk.Impl.exists","text":"TclTk.exists(interp=TclInterp(), name)\nhaskey(interp, name)\n\nReturn whether global variable name is defined in Tcl interpreter interp or in the shared interpreter of the calling thread if this argument is omitted. Variable name may be a 2-tuple (part1, part2).\n\nSee also\n\nTclTk.getvar, TclTk.setvar!, and TclTk.unsetvar!.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.getvar","page":"Public API","title":"TclTk.Impl.getvar","text":"TclTk.getvar(T=TclObj, interp=TclInterp(), name) -> val::T\ninterp[name] -> val::TclObj\ninterp[T::Type, name] -> val::T\n\nReturn the value of the global variable name in Tcl interpreter interp or in the shared interpreter of the calling thread if this argument is omitted. Variable name may be a 2-tuple (part1, part2).\n\nOptional argument T (TclObj by default) can be used to specify the type of the returned value. Some possibilities are:\n\nIf T is TclObj (the default), a managed Tcl object is returned. This is the most efficient if the returned value is intended to be used in a Tcl list or as an argument of a Tcl script or command.\nIf T is Bool, a boolean value is returned.\nIf T is String, a string is returned.\nIf T is Char, a single character is returned (an exception is thrown if Tcl object is not a single character string).\nIf T <: Integer, an integer value of type T is returned.\nIf T <: AbstractFloat, a floating-point value of type T is returned.\n\nNote that, except if T is TclObj, a conversion of the Tcl object stored by the variable may be needed.\n\nSee also\n\nTclTk.exists, TclTk.setvar!, and TclTk.unsetvar!.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.setvar!","page":"Public API","title":"TclTk.Impl.setvar!","text":"TclTk.setvar!(interp=TclInterp(), name, value) -> nothing\ninterp[name] = value\n\nTclTk.setvar!(T, interp=TclInterp(), name, value) -> val::T\n\nSet global variable name or part1(part2) to be value in Tcl interpreter interp or in the shared interpreter of the calling thread if this argument is omitted. Variable name may be a 2-tuple (part1, part2).\n\nThe Tcl variable is deleted if value is unset, the singleton provided by the UnsetIndex package and exported by the Tcl package.\n\nIn the last case, the new value of the variable is returned as an instance of type T (can be TclObj). The new value may be different from value because of trace(s) associated to this variable.\n\nSee also\n\nTclTk.getvar, TclTk.exists, and TclTk.unsetvar!.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.unsetvar!","page":"Public API","title":"TclTk.Impl.unsetvar!","text":"TclTk.unsetvar!(interp=TclInterp(), name)\ninterp[name] = unset\ndelete!(interp, name) -> interp\n\nDelete global variable name in Tcl interpreter interp or in the shared interpreter of the thread if this argument is omitted. Variable name may be a 2-tuple (part1, part2). Above, unset is the singleton provided by the UnsetIndex package and exported by the TclTk package.\n\nKeywords\n\nKeyword nocomplain can be set true to ignore errors. By default, nocomplain=false.\n\nKeyword flag can be set with bits such as TCL_GLOBAL_ONLY (set by default) and TCL_LEAVE_ERR_MSG (set by default unless nocomplain is true).\n\nSee also\n\nTclTk.getvar, TclTk.exists, and TclTk.setvar!.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.tk_start","page":"Public API","title":"TclTk.Impl.tk_start","text":"tk_start(interp = TclInterp()) -> interp\n\nLoad Tk and Ttk packages in interp and start the event loop (for all interpreters).\n\nnote: Note\ntk_start also takes care of withdrawing the root window \".\" to avoid its destruction as this would terminate the Tcl application. Execute Tcl command wm deiconify . to show the root window again.\n\nSee also\n\nTclTk.resume, TclInterp, and TkWidget.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.do_events","page":"Public API","title":"TclTk.Impl.do_events","text":"TclTk.do_events(flags = TCL_DONT_WAIT|TCL_ALL_EVENTS) -> num::Int\n\nProcess Tcl/Tk events for all interpreters by calling TclTk.do_one_event(flags) until there are no events matching flags and return the number of processed events. Normally this is automatically called by the timer set by TclTk.resume.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.do_one_event","page":"Public API","title":"TclTk.Impl.do_one_event","text":"TclTk.do_one_event(flags = TCL_DONT_WAIT|TCL_ALL_EVENTS) -> bool\n\nProcess at most one Tcl/Tk event for all interpreters matching flags and return whether one such event was processed. This function is called by TclTk.do_events.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.resume","page":"Public API","title":"TclTk.Impl.resume","text":"TclTk.resume(delay=0.1, interval=0.05) -> nothing\n\nResume or start the processing of Tcl/Tk events with a given delay and interval both in seconds. This manages to repeatedly call function TclTk.do_events. The method TclTk.suspend can be called to suspend the processing of events.\n\nCalling TclTk.resume is mandatory when Tk extension is loaded. Thus, the recommended way to load the Tk package is:\n\nTclTk.eval(interp, \"package require Tk\")\nTclTk.resume()\n\nor alternatively:\n\ntk_start()\n\ncan be called to do that.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.suspend","page":"Public API","title":"TclTk.Impl.suspend","text":"TclTk.suspend() -> nothing\n\nSuspend the processing of Tcl/Tk events for all interpreters. The method TclTk.resume can be called to resume the processing of events.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.TkWidget","page":"Public API","title":"TclTk.Impl.TkWidget","text":"TkWidget(interp=TclInterp(), path)\n\nReturn a widget for the given Tk window path in interpreter interp. The type of the widget is inferred from the class of the Tk window.\n\n\n\n\n\n","category":"type"},{"location":"public/#TclTk.Impl.cget","page":"Public API","title":"TclTk.Impl.cget","text":"TclTk.cget(w, opt)\n\nReturn the value of the option opt for Tk object (widget or image) w. Option opt may be specified as a string or as a Symbol and shall corresponds to a Tk option name without the leading \"-\". Another way to obtain an option value is:\n\nw[opt]\n\nSee also\n\nTclTk.configure and TkWidget.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.configure","page":"Public API","title":"TclTk.Impl.configure","text":"TclTk.configure(w)\nw(:configure)\n\nReturn all the options of Tk object (widget or image) w.\n\n\n\nTclTk.configure(w, opt1 => val1, opt2 => val2)\nw(:configure, opt1 => val1, opt2 => val2)\n\nChange some options of widget w. Options names (opt1, opt2, ...) may be specified as string or Symbol and shall correspond to Tk option names without the leading \"-\". Another way to change the settings is:\n\nw[opt1] = val1\nw[opt2] = val2\n\nSee also\n\nTclTk.cget and TkWidget.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.grid","page":"Public API","title":"TclTk.Impl.grid","text":"TclTk.grid(args...)\n\nCall Tk grid geometry manager. One of the arguments must be a widget (that is an instance of TkWidget). All widgets in args... must live in the same interpreter.\n\nSee also\n\nTclTk.pack and TclTk.place.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.pack","page":"Public API","title":"TclTk.Impl.pack","text":"TclTk.pack(args...)\n\nCall Tk packer geometry manager. One of the arguments must be a widget (that is an instance of TkWidget). All widgets in args... must live in the same interpreter.\n\nFor example:\n\nusing TclTk\ntk_start()\ntop = TkToplevel()\nTclTk.exec(Nothing, :wm, :title, top, \"A simple example\")\nbtn = TkButton(top, :text => \"Click me\", :command => \"puts {ouch!}\")\nTclTk.pack(Nothing, btn, :side => :bottom, :padx => 30, :pady => 5)\n\nSee also\n\nTclTk.grid and TclTk.place.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.place","page":"Public API","title":"TclTk.Impl.place","text":"TclTk.place(args...)\n\nCall Tk placer geometry manager. One of the arguments must be a widget (that is an instance of TkWidget). All widgets in args... must live in the same interpreter.\n\nSee also\n\nTclTk.grid and TclTk.pack.\n\n\n\n\n\n","category":"function"},{"location":"public/#TclTk.Impl.TkImage","page":"Public API","title":"TclTk.Impl.TkImage","text":"TkImage{type}(host=TclInterp(), option => value, ...) -> img\nTkImage{type}(host=TclInterp(), name, option => value, ...) -> img\n\nReturn a Tk image of given type (e.g., :bitmap, :pixmap, or :photo).\n\nnote: Note\nTk extension must have been loaded in the interpreter before creating an image. This can be done with tk_start.\n\nArgument hosts is used to infer the Tcl interpreter where lives the image (the shared interpreter of the thread by default). If host is a Tk widget, its interpreter is used.\n\nIf the image name is omitted, it is automatically generated. If name is specified and an image with this name already exists in the interpreter, it is re-used and, if options are specified, it is reconfigured.\n\nThere may be any option => value pairs to (re)configure the image. Options depend on the image types.\n\nA Tk image can then be used in any Tcl/Tk script or command where an image is expected.\n\nTk images implement the abstract array API. To extract the pixels of an image, the img[x,y] syntax may be used with x and y pixel indices or ranges. For a :photo image, pixel values are represented by RGBA{N0f8} colors.\n\nA Tk image has a number of properties:\n\nimg.inuse    # whether an image is in use in a Tk widget\nimg.width    # the width of the image in pixels\nsize(img, 1) # idem\nimg.height   # the height of the image in pixels\nsize(img, 2) # idem\nimg.size     # (width, height)\nsize(img)    # idem\nimg.type     # the symbolic type of the image (`:bitmap`, `:pixmap`, `:photo`, etc.)\nimg.name     # the image name in its interpreter\nimg.interp   # the interpreter hosting the image\n\nSee also\n\nTkBitmap, TkPhoto, and TkPixmap are aliases for specific image types.\n\ntk_start, and TclInterp.\n\n\n\n\n\nTkImage(host=TclInterp(), name, option => value, ...) -> img\n\nReturn an instance of TkImage managing Tk image named name in the Tcl interpreter specified by host (can be a Tk widget) and after applying any options specified by the trailing option => value, ... pairs.\n\n\n\n\n\n","category":"type"},{"location":"public/#TclTk.Impl.TkBitmap","page":"Public API","title":"TclTk.Impl.TkBitmap","text":"TkBitmap(args...) -> img\nTkImage{:bitmap}(args...) -> img\n\nReturn a Tk bitmap image. See TkImage for more information.\n\n\n\n\n\n","category":"type"},{"location":"public/#TclTk.Impl.TkPixmap","page":"Public API","title":"TclTk.Impl.TkPixmap","text":"TkPixmap(args...) -> img\nTkImage{:pixmap}(args...) -> img\n\nReturn a Tk pixmap image. See TkImage for more information.\n\n\n\n\n\n","category":"type"},{"location":"public/#TclTk.Impl.TkPhoto","page":"Public API","title":"TclTk.Impl.TkPhoto","text":"TkPhoto(args...) -> img\nTkImage{:photo}(args...) -> img\n\nReturn a Tk photo image. See TkImage for more information.\n\n\n\n\n\n","category":"type"},{"location":"callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"TclTk is a Julia package for interacting with Tcl/Tk.\n\nThe source code of TclTk is on GitHub.","category":"section"},{"location":"#Table-of-contents","page":"Introduction","title":"Table of contents","text":"Pages = [\"objects.md\", \"lists.md\", \"interpreters.md\", \"callbacks.md\", \"widgets.md\", \"dialogs.md\", \"images.md\", \"public.md\", \"develop.md\",]","category":"section"},{"location":"implementation/#Orgianization","page":"-","title":"Orgianization","text":"module Tcl\n    module Impl\n        # imports definitions from ..LibTcl and ..LibTk\n        using ..LibTcl\n        using ..LibTk\n\n    end\n    module LibTcl\n        # provide calls to Tcl library\n        include(\"../deps/tcldefs.jl\")\n    end\n    module LibTk\n       # imports definitions from LibTcl\n       using ..LibTcl\n       # provide calls to Tk library\n       include(\"../deps/tkdefs.jl\")\n    end\nend\n\nMost Tcl functions require a Tcl interpreter or that at least one Tcl interpreter has been created and that Tcl_Init has been called.  Simlarly for Tk, Tk_init must have been called otherwise even simple functions like Tk_GetUid wont't work or cause errors like segmentation faults.\n\nA ccall like:\n\nccall((:SomeFunction, SomeLibrary), SomeReturnType, (Ptr{Cvoid},), x)\n\nwith an argument x of type T requires that T <: Ptr, T <: Ref or Base.unsafe_convert(::Type{Ptr{Cvoid}},x::T) exists.\n\nA ccall like:\n\nccall((:SomeFunction, SomeLibrary), SomeReturnType, (Ptr{SomeType},), x)\n\nwhere SomeType is not Cvoid (that is Nothing) with an argument x of type T requires that T <: Ptr{Cvoid}, T <: Ptr{SomeType}, T <: Ref{SomeType}, T <: Array{SomeType} or Base.unsafe_convert(::Type{Ptr{SomeType}},x::T) exists.\n\nIt is possible to wrap a pointer to an opaque structure into an immutable structure to enforce some kind of type checking:\n\nstruct OpaqueTypeAddress; addr::UInt; end\nstruct OpaqueTypePointer; addr::Ptr{Cvoid}; end\n\nthe two are almost equivalent and are fast but be aware that, as the type is immutable you cannot prevent garbage collection.\n\nFrom the semantics of Refvalue{T} and its definition in revalue.jl in Julia base sources, I deduce that some code like:\n\nfunction somefunction(x)\n    rx = Ref(x) # same as Ref{typeof(x)}(x)\n    ccall((:SomeFunction, SomeLibrary), SomeReturnType, (Ptr{SomeType},), rx)\nend\n\nis ok even though argument x may be a temporary object (e.g., an expression) because making a mutable object out of it and passing it to ccall prevents rx (and therefore x) to be garbage collected before ccall returns.","category":"section"}]
}
