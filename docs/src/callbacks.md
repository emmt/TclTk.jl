# Callbacks

A callback is a Julia functions associated to a command in a given Tcl interpreter. Whenever
the associated command is executed by the Tcl interpreter, the Julia function is called with
the command arguments (a list of Tcl objects).


## Simple callback example

To show how callbacks work, we start with a simple example:

```julia-repl
julia> function myfunc(interp::TclInterp, args::TclObj)
           io = stdout
           print(io, "Called with arguments: ")
           show(io, args)
       end
myfunc (generic function with 1 method)

julia> cb = TclTk.Callback(myfunc, "jl_myfunc")
TclTk.Callback: `myfunc` (in Julia) => "::jl_myfunc" (in Tcl)

julia> TclTk.exec(Nothing, "jl_myfunc", :arg1, 2, 3.0, "4th arg")
Called with arguments: TclObj(("jl_myfunc", "arg1", 2, 3.0, "4th arg",))

```

In the above example:

* A Julia function is defined with the expected signature for a callback. When this function
  is called, `interp` is the calling Tcl interpreter and `args` is a Tcl list of objects.
  The first element of `args` is the name of the calling Tcl command while subsequent
  elements in `args` are the arguments given to the command.

* The constructor `TclTk.Callback` is called to associate the Julia function with a new
  command named `"jl_myfunc"` in a Tcl interpreter. Since no interpreter is specified in
  this example, the shared Tcl interpreter of the thread is assumed.

* The command is executed by [`TclTk.exec`](@ref) with a number of arguments to demonstrate
  how they are transmitted to the Julia function.


## Callback constructor arguments

The `TclTk.Callback` constructor may be called with up to 3 arguments:

* A mandatory Julia function. This function is called when the associated Tcl command is
  executed.

* An optional Tcl interpreter assumed to be the shared interpreter of the thread by default.
  The associated Tcl command lives in this interpreter.

* An optional command name. A name of the form `"jl_func_$n"` is automatically generated by
  default with `$n` a unique integer. For a callback `cb`, the actual command name is given
  by `cb.name` even though the command is renamed.


## Callback return value

A Tcl command shall return 2 things: a *status* (a value of type [`TclStatus`](@ref)) and a
*result*. If the *status* is `TCL_OK`, the command is assumed to be successful with a
returned value given by the *result*. If the *status* is `TCL_ERROR`, the command is assumed
to have failed with an error message given by the *result*. To reflect this behavior, a
callback function may return:

* A 2-tuple `(status::TclStatus, result)` to specify both the status and the result.

* A `status` of type [`TclStatus`](@ref) to assume an empty result. This is the same as
  returning the 2-tuple `(status, "")`.

* A `result` of any other type than [`TclStatus`](@ref) to assume a successful status. This
  is the same as returning the 2-tuple `(TCL_OK, result)`.

* `nothing` (as `myfunc` in the above example) to assume a successful status and an empty
  result. This is the same as returning the 2-tuple `(TCL_OK, "")`.

Furthermore, any exception thrown by the callback function is catch and reported to the
calling interpreter with a `TCL_ERROR` status and a result set with the error message.


## Callback properties

A callback, say `cb`, has the following properties:

* `cb.func` is the Julia function of the callback.

* `cb.interp` is the Tcl interpreter where lives the command associated with the callback.

* `cb.name` is the name of the Tcl command associated with the callback. This name is
  prefixed by the full namespace path so that it can be used in any Tcl script and from any
  Tcl namespace. Hence, this name always starts by `"::"`.

* `cb.token` is a private address used by the Tcl interpreter to find the command (whatever
  its name).

Tcl commands may be renamed in their interpreter, e.g. by calling the `rename` Tcl command.
If the callback command is renamed, the property `cb.name` keeps track of the full command
name.


## GUI callback example

As another callback example, we build a simple Graphical User Interface (GUI) where the
location of mouse clicks are reported:

```julia-repl
julia> tk_start(); # make sure Tk package is loaded and event loop is running

julia> top = TkToplevel(:background => "#282c34")
TkToplevel(".top1")

julia> TclTk.exec(Nothing, :wm, :title, top, "Callback demo")

julia> canvas = TkCanvas(top, :background => "#282c34", :cursor => :target)
TkCanvas(".top1.cnv1")

julia> mesg = TkMessage(top, :aspect => 600)
TkMessage(".top1.msg1")

julia> TclTk.pack(Nothing, canvas, :side => :top, :fill => "both", :expand => true)

julia> TclTk.pack(Nothing, mesg, :side => :bottom, :fill => "x", :expand => false)

julia> function on_click(interp::TclInterp, args::TclObj)
           # Extract arguments (4 expected).
           cmd = args[1 => String]  # the name of the calling command
           win = args[2 => String]  # the widget name, %W in the bind script
           xm = args[3 => Float64] # the x coordinate of the event, %x in the bind script
           ym = args[4 => Float64] # the y coordinate of the event, %x in the bind script
           # Convert (xm,ym) to canvas coordinates.
           x = interp(Float64, win, :canvasx, xm)
           y = interp(Float64, win, :canvasy, xm)
           # Set message.
           s = "Mouse clicked at ($xm, $ym) with canvas coordinates ($x, $y)."
           interp(Nothing, mesg, :configure, :text => s)
       end
on_click (generic function with 1 method)

julia> cb = TclTk.Callback(on_click)
TclTk.Callback: `on_click` (in Julia) => "::jl_func_1" (in Tcl)

julia> TclTk.exec(Nothing, :bind, canvas, "<ButtonPress-1>", (cb.name, "%W", "%x", "%y"))

```
